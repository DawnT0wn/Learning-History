# 常见的命令执行的管道符

## Windows管道符

|直接用来执行后面的语句

![image-20210720140523028](images/1.png)

但是如果|的前面为假则不执行后面语句

![image-20210720140626530](images/2.png)

&的前后语句都会执行而且无论前后的真假

![image-20210720141008946](images/3.png)

![image-20210720141050370](images/4.png)

&&前面为假则不执行,前面为假则执行两条语句

![image-20210720144333173](images/5.png)

## Linux的管道符

`|、||、&、&&`这四种管道符都存在且用法和`Windows`系统下一样，多了一个`;`管道符，作用和`&`一样

在linux下，命令分隔符除了`;`还有%0a,不过要注意url会不会将%0a编码，如果要就在url中输入

# 命令执行漏洞bypass

## 空格过滤

```
用${IFS},$IFS绕过空格
```

![image-20210721171403808](images/6.png)

```
利用重定向符<>绕过空格
```

![image-20210721171843675](images/7.png)

```
利用%09,%20绕过空格(需要php环境)
```

![image-20210721172353679](images/8.png)

```
利用花括号
```

![image-20220813102007289](images/9.png)

## 绕过黑名单

### 拼接绕过:

![image-20210721173011607](images/10.png)

在有些题目里面他把flag办掉了,可以用这种拼接方法，但是要注意辅助的时候不能按顺序来,不然也会被检测到

### 利用base64编码绕过

```
cat flag的base64编码为Y2F0IGZsYWc=
```

![image-20210721173442927](images/11.png)

一定要加反引号,而且还有对`base64`进行解码`base64 -d`

若不加反引号,则需要加bash命令

![image-20210721173635820](images/12.png)

### 利用16进制编码绕过

```
echo "63617420666c6167" | xxd -r -p|bash
```

![image-20220813101711578](images/13.png)

### $()绕过

$() 会将包裹的字符作为命令

```
$(printf "\x63\x61\x74\x20\x66\x6c\x61\x67")
`printf "\x63\x61\x74\x20\x66\x6c\x61\x67"`
```

![image-20220813101803653](images/14.png)

### 利用单引号,双引号绕过

有些用黑名单禁用了cat,flag等字符,可以用单引号双引号绕过

![image-20210721173753772](images/15.png)

### 利用\绕过

黑名单还可以用反斜杠来绕过对cat等的禁用

![image-20210721173914180](images/16.png)

### 利用`$1,$2,$@`绕过

![image-20210721174027224](images/17.png)

`$3`,`$4`这些也可以

### 利用花括号笛卡尔积绕过

花括号

1. 花括号可以表示固定变量名

2. 花括号可以表示两个数组的笛卡尔积

![image-20220813101308058](images/18.png)

## 读文件时的绕过

有时cat被完全过滤掉了就不知道怎么办了,其实linux下有很多读文件的命令

```
(1)more:一页一页的显示档案内容
(2)less:与 more 类似，但是比 more 更好的是，他可以直接打开文件[page down][page up]翻页
(3)head:查看头几行
(4)tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示
(5)tail:查看尾几行
(6)nl：显示的时候，顺便输出行号
(7)od:以二进制的方式读取档案内容
(8)vi:一种编辑器，这个也可以查看
(9)vim:一种编辑器，这个也可以查看
(10)sort:可以查看
(11)uniq:可以查看
(12)file -f:报错出具体内容
```

![image-20210721174510925](images/19.png)

## 通配符绕过

linux的通配符

![img](http://www.iis7.com/uploads/cj/201911/20179183927950.png)

利用通配符匹配我们的命令,linux的系统命令其实是在bin文件夹下的

![image-20210721180451845](images/20.png)

![image-20210721180619784](images/21.png)

## 内敛执行绕过

在linux中反引号和$都可以用来先执行命令

![image-20210721201827511](images/22.png)

## 绕过长度限制的命令执行

### linux的>和>>符号

在linux中可以用>来创建一个文件

![image-20210721202120687](images/23.png)

然后可以用>来载入文件内容,但是会覆盖掉原内容

![image-20210721202454120](images/24.png)

但是>>则是在文件末尾添加内容,对原内容并无影响

![image-20210721202526596](images/25.png)

### linux中的命令换行

在linux中,可以用\来多行执行命令

![image-20210721203152279](images/26.png)

这样我们就可以在某些对长度进行限制的地方命令执行,用一个文本一行一行的输入要执行的命令,最后再执行这个文本

![image-20210721203720088](images/27.png)

sh命令可以从一个文件里面来读取内容执行命令,和那个上传临时文件来进行无字母rce是一样的

使用了两个 \ 是因为我们需要转义掉多行命令的换行，如果我们只使用一个 \ 那么就会被误解为正在多行执行命令

![image-20210721203803752](images/28.png)

### 利用ls -t 和 > 以及换行符 绕过长度限制执行命令

在linux中,命令`ls -t`可以将文件按创建的先后顺序排列出来(后创建的排在前面)

![image-20210721204431089](images/29.png)

其实`ls -t`的结果一样是可以写入一个文本里面的

![image-20210721204812800](images/30.png)

和上面思路一样,我们是不是可以将命令分开创建为文件然后`ls -t`写入文本,最后sh执行文本

![image-20210721211130110](images/31.png)

### hitcon 2017 babyfirst-revenge

这道题需要一台vps,并且将index.php改为bash反弹shell的命令



参考链接:

https://xz.aliyun.com/t/2748

https://blog.csdn.net/ghtwf01/article/details/110440558?spm=1001.2014.3001.5501

